# 0. 项目背景

Project3：在瑞芯微板子麒麟系统实现简单的局域网飞秋功能。

1. 可以建立无需服务器的聊天室,具有群聊天室的功能.

2. 搜索用户功能，可通过输入用户名、组名、IP等来查找我的好友.

3. 分组功能，给所有在线的用户群发消息及分组群发功能.

4. 支持表情包发送(可自定义表情包)、截图功能。

5. 在应用中调用 npu 实现 ai 应用.

# 1. 项目定位与核心挑战

## 1.1. 项目定位

一个**“下一代智能局域网协作套件”**。

- **核心功能 (类飞秋):** 局域网P2P自动发现、即时通讯、文件/文件夹传输、群聊。
    
- **核心创新 (AI + 加速):**
    
    1. **AI 功能:** NSFW 检测、聊天摘要、智能搜索（语义搜索）、消息翻译。
        
    2. **硬件加速:** 在 Windows 上利用 GPU (CUDA/DirectML) 加速 AI 推理；在 RK3566 上利用 NPU 加速 AI 推理。
        

## 1.2. 核心挑战

1. **跨平台与硬件异构:** 需要一套代码兼容 x86_64 (Windows) 和 <em>ARM</em>64 (Linux/RK3566)。
    
2. **AI 模型选型:** 模型必须足够小和高效，以便在客户端本地运行（尤其是 NSFW 和语义搜索的 embedding 模型）。
    
3. **异构加速抽象:** 如何编写一次 AI 功能代码，让它能自动调用 GPU (Windows) 或 NPU (RK3566)，并在两者都不可用时回退到 CPU？
    
4. **P2P 通信:** 在现代网络环境中（尤其是 Wi-Fi），UDP 广播的可靠性。
    
5. **数据一致性:** P2P 架构下的消息历史、文件索引等数据管理。
    

# 2. 规范的软件开发与管理范式

## 2.1. 开发模型：Agile (敏捷开发)

对于这种需求尚不完全明确、技术复杂度高的项目，采用敏捷开发（例如 **Scrum** 或 **Kanban**）。

- **迭代 (Iteration):** 以 1-2 周为一个“冲刺” (Sprint)，每个冲刺结束时都应产出一个可测试、可交付的功能子集。
    
- **优先级 (根据 Project3 核心需求重新编排):**
    
    - **Sprint 1: 核心 P2P 通信 (Windows 平台验证)**
        
        - 实现 `PeerDiscovery` (UDP 广播) 和 `PeerSession` (TCP 长连接)。
            
        - 目标：实现两个 Windows 客户端 1v1 的文本聊天。
            
    - **Sprint 2: 用户体系与分组 (满足需求 2, 3)**
        
        - 在 `UserInfo` 协议 (4.1) 和 `PeerNodes` 数据库 (6) 中增加 `group_name` 字段。
            
        - UI 实现好友列表、在线用户搜索（按用户名、IP、组名）。
            
        - 实现客户端本地的用户分组逻辑。
            
    - **Sprint 3: 群聊与文件 (满足需求 1, 3)**
        
        - 实现群聊功能（逻辑：遍历会话列表，P2P 消息多发）。
            
        - 实现“对所有人广播”和“按组群发”功能。
            
        - 实现基础的文件传输模块。
            
    - **Sprint 4: 高级功能与跨平台 (满足需求 4)**
        
        - **(截图)** 调用平台 API (Windows GDI/Linux X11) 实现截图功能，并通过文件传输发送。
            
        - **(表情包)** 实现内置表情包发送。实现自定义表情包（作为文件包）的添加与传输。
            
        - **(跨平台)** 首次在 RK3566 麒麟系统上编译并运行核心通信功能。
            
    - **Sprint 5: NPU 加速实现 (满足需求 5 - NSFW)**
        
        - 实现 `AIEngine` (AI 引擎) 和 `I_Accelerator` (硬件抽象层)。
            
        - 重点实现 `Rk3566NpuEngine`，调用 `librknnrt` 库。
            
        - **目标：实现高优先级的 NSFW 检测功能 (双端检测)。在 RK3566 上跑通第一个 AI 应用（例如 NSFW 检测），并集成到聊天应用中。**
            
    - **Sprint 6: 完整 AI 加速与优化**
        
        - 实现 `WindowsGpuEngine` (DirectML/CUDA) 和 `CpuFallbackEngine`。
            
        - 优化 AI 模型，按优先级逐步完善 AI 功能（如语义搜索、消息翻译）。聊天摘要功能（因其高资源消耗）将推迟实现。
## 2.2. 版本控制：Git 工作流

使用 Git。推荐使用 **GitFlow** 或更简化的 **GitHub Flow**。

- **`main` / `master` 分支:** 始终保持可发布状态。
    
- **`develop` 分支:** 开发的主干。
    
- **`feature/xxx` 分支:** 开发新功能（如 `feature/npu-acceleration`）。
    
- **`release/v1.1` 分支:** 准备发布新版本时使用。
    
- **`hotfix/xxx` 分支:** 修复线上紧急 Bug。
    
- **Commit 规范:** 使用“约定式提交” (Conventional Commits)，例如 `feat: add voice-to-text module` 或 `fix(npu): resolve memory leak in rknn_run`。
    

## 2.3. 构建与管理：DevOps / CI/CD

由于是跨平台项目，自动化构建和测试至关重要。

- **CI/CD (持续集成/持续交付):** 使用 **GitHub Actions** 或 **GitLab CI**。
    
- **自动化流水线 (Pipeline):**
    
    1. **Commit 触发:** 开发者提交代码到 `feature` 分支。
        
    2. **单元测试:** 自动运行所有平台的单元测试。
        
    3. **构建 (Build):**
        
        - 在 Windows Runner (x64) 上编译 Windows 版本。
            
        - 在 Linux Runner (ARM64) 上交叉编译或本地编译 RK3566 版本 (使用 Docker + QEMU 或专门的 ARM Runner)。
            
    4. **打包 (Package):** 生成 `.exe` 安装包 (Windows) 和 `.deb` 或 AppImage (Linux)。
        
    5. **部署 (Deploy):** 自动将构建产物发布到内部测试服务器或 GitHub Release。
        

# 3. 科学的软件架构设计

这是项目的核心。我们将采用“高内聚、低耦合”的模块化设计。

## 3.1. 顶层架构：模块化的 MVVM

使用 **MVVM (Model-View-ViewModel)** 模式，它非常适合需要跨平台共享业务逻辑的 UI 应用。

- **View (视图层):** 平台原生 UI。
    
    - _Windows:_ WinUI 3 / WPF / C++ (Qt/QML)
        
    - _RK3566:_ C++ (Qt/QML) 或 Flutter
        
- **ViewModel (视图模型层):** UI 的状态和逻辑，不包含 UI 控件。**这一层应 90% 跨平台复用。**
    
- **Model (模型与服务层):** 核心业务逻辑、通信、AI、数据库。**这一层应 100% 跨平台复用（除了硬件抽象的实现）。**
    

## 3.2. 核心服务模块 (Model 层)

```
[ (View Layer) ]  <-- Data Binding --> [ (ViewModel Layer) ]
       |                                       |
       +------------------[ (ServiceBus) ]------------------+
                          |            |                   |
    [ Communication ] [ AI Engine ] [ Data Storage ] [ Platform Service ]
    |    - PeerDiscovery  |             |                  |
    |    - Messaging      |             |                  |
    |    - FileTransfer   |             |                  |
    +---------------------+             |                  |
                          |             |                  |
    [ (Hardware Abstraction Layer - HAL) ] <---+            |
    |   - I_Accelerator (Interface)      |   |            |
    |   - WindowsGpuEngine (Impl)        |   |            |
    |   - Rk3566NpuEngine (Impl)         |   |            |
    |   - CpuFallbackEngine (Impl)       |   |            |
    +------------------------------------+   |            |
                                             |            |
    [ (Database Abstraction Layer - DAL) ] <---+            |
    |   - I_Repository (Interface)         |                |
    |   - SqliteRepository (Impl)          |                |
    +------------------------------------+                |
```
### 1. 通信模块 (Communication Service)

- **P2P 核心:** 负责局域网内的节点发现、消息收发和文件传输。
    
- **PeerDiscovery (节点发现):**
    
    - **主通道:** 使用 **UDP 广播** (IPv4) 或 **组播** (IPv6) 定时（如 5 秒）发送“我是谁” (Online) 消息。
        
    - **辅助通道:** mDNS (Bonjour/ZeroConf) 也可以作为补充，更适合现代网络。
        
    - **节点列表:** 内存中维护一个“在线用户列表”，包含 IP、端口、用户名、主机名、AI 能力（是否带 NPU/GPU）。
        
- **Messaging (消息服务):**
    
    - 使用 **TCP 长连接**。一旦通过 UDP 发现对方，就建立 TCP 连接用于可靠的消息传输（聊天、指令）。
        
    - **协议:** 使用**Protobuf (Protocol Buffers)** 或 JSON 定义消息体。Protobuf 性能更高，更适合 C++。
        
- **FileTransfer (文件服务):**
    
    - 使用**独立的 TCP 端口**进行文件传输，避免阻塞消息通道。
        
    - 支持多线程/异步 I/O，支持断点续传。
        

### 2. AI 引擎 (AI Engine) - 【核心】

这是实现 NPU/GPU 加速的关键。我们必须设计一个**硬件抽象层 (Hardware Abstraction Layer, HAL)**。

- **推理引擎标准:** 选用 **ONNX Runtime**。
    
    - ONNX 是一个开放的 AI 模型标准。
        
    - ONNX Runtime 是一个跨平台的推理引擎，它支持多种“执行提供程序” (Execution Provider)。
        
- **抽象接口 (C++ 示例):**
    
    ```
    // ai_accelerator.h
    enum class AiTask {
        NsfwDetection,         // NSFW 内容检测
        ChatSummary,           // 聊天摘要
        SemanticEmbedding,     // 语义搜索（生成向量）
        MessageTranslation     // 消息翻译
    };
    
    class I_Accelerator {
    public:
        virtual ~I_Accelerator() = default;
        virtual bool Initialize() = 0;
        virtual std::string GetProviderName() = 0; // "CPU", "CUDA", "DirectML", "RKNPU"
        virtual bool IsSupported(AiTask task) = 0;
        // 具体的推理方法可以更专用，以提高类型安全
        virtual bool RunNsfwCheck(const void* imageData, size_t size) = 0;
        virtual std::string RunTranslation(const std::string& text, const std::string& targetLang) = 0;
        virtual std::vector<float> RunEmbedding(const std::string& text) = 0;
        // 聊天摘要将是一个高成本操作
        virtual std::string RunSummary(const std::string& longText) = 0;
    };
    ```
    
- **具体实现 (Impl):**
    
    1. **`WindowsGpuEngine.cpp` (Windows 平台):**
        
        - 使用 ONNX Runtime + **DirectML** (支持 AMD/Intel/Nvidia) 或 **CUDA** (仅 Nvidia) 执行提供程序。
            
        - `Initialize()`: 尝试加载 DirectML/CUDA 引擎。
            
    2. **`Rk3566NpuEngine.cpp` (RK3566 平台):**
        
        - **关键:** RK3566 的 NPU 使用 `rknn-toolkit2`。你需要先把 ONNX 模型（例如**一个轻量级的 NSFW 检测模型 (如 nsfw_detector.onnx)**）**离线转换**为 `.rknn` 模型。
            
        - 使用 Rockchip 提供的 `librknnrt.so` 库 (C API) 来加载和运行 `.rknn` 模型。
            
        - `Initialize()`: 尝试 `rknn_init()`。
            
    3. **`CpuFallbackEngine.cpp` (所有平台):**
        
        - 使用 ONNX Runtime + **CPU** 执行提供程序。
            
        - `Initialize()`: 总是返回 true。
            
- **AI 引擎工厂 (Factory):**
    
    - 应用启动时，工厂会**按顺序**尝试初始化加速器：
        
    - _在 Windows 上:_ `new WindowsGpuEngine()` -> (失败?) -> `new CpuFallbackEngine()`
        
    - _在 RK3566 上:_ `new Rk3566NpuEngine()` -> (失败?) -> `new CpuFallbackEngine()`
        
    - 上层业务（ViewModel）只调用 `I_Accelerator` 接口，无需关心底层是 NPU 还是 GPU。
### 3. 数据存储 (Data Storage)

- **数据库选型:** **SQLite**。
    
    - 它是轻量级、嵌入式、跨平台的完美选择。
        
    - 用于存储：聊天记录、文件传输历史、用户配置。
        
- **AI 数据:**
    
    - **全文搜索 (FTS):** 使用 SQLite 的 **FTS5** 扩展来实现聊天记录的快速全文检索。
        
    - **语义搜索 (向量):** 如果要做智能搜索，需要存储 AI 生成的“向量” (Embeddings)。可以在 SQLite 中存储为 `BLOB`，并使用 `Faiss` (Facebook AI Similarity Search) 库（CPU）进行相似度计算。
        

# 4. 科学的通信协议设计

P2P 通信协议必须简洁、可扩展。

- **基础:** 基于 UDP (发现) + TCP (数据)。
    
- **数据格式:** Protobuf (推荐) 或 JSON。
    

### 4.1. 消息类型 (Protobuf 示例)

```
// message.proto
syntax = "proto3";

enum MessageType {
  // --- 基础通信 (UDP/TCP) ---
  MSG_ONLINE = 0;        // 上线通知 (UDP 广播)
  MSG_OFFLINE = 1;       // 下线通知 (UDP 广播)
  MSG_PING = 2;          // PING (TCP)
  MSG_PONG = 3;          // PONG (TCP)

  // --- 聊天 (TCP) ---
  MSG_TEXT_CHAT = 10;    // 文本消息
  MSG_FILE_REQUEST = 11; // 文件传输请求
  MSG_EMOTICON = 12;     // 表情包消息 (ID 或自定义包)

  // --- AI 消息 (TCP) ---
  MSG_AI_TRANSLATE_REQUEST = 20; // 请求对方（高性能节点）帮忙翻译
  MSG_AI_TRANSLATE_RESPONSE = 21;// 翻译结果
  
  // (新增) 针对高消耗的聊天摘要
  MSG_AI_SUMMARY_REQUEST = 30;   // 请求对方帮忙摘要
  MSG_AI_SUMMARY_RESPONSE = 31;  // 摘要结果
}

// ------------------------------------
// 节点信息 (用于 MSG_ONLINE)
// ------------------------------------
message UserInfo {
  string user_id = 1;
  string user_name = 2;
  string host_name = 3;
  
  message HardwareInfo {
    bool has_gpu = 1;
    bool has_npu = 2;
    string platform = 3; // "Windows", "Linux <em>ARM</em>64"
  }
  HardwareInfo hardware = 4;
  string group_name = 5; // **新增：用于支持分组功能 (需求 2, 3)**
}

// ------------------------------------
// AI 翻译请求 (用于 MSG_AI_TRANSLATE_REQUEST)
// ------------------------------------
message AiTranslateRequest {
  string text_to_translate = 1;
  string target_language = 2; // "en", "zh", etc.
}

// ------------------------------------
// AI 翻译响应 (用于 MSG_AI_TRANSLATE_RESPONSE)
// ------------------------------------
message AiTranslateResponse {
  string original_text = 1;
  string translated_text = 2;
}

// ------------------------------------
// AI 摘要请求 (用于 MSG_AI_SUMMARY_REQUEST)
// ------------------------------------
message AiSummaryRequest {
  string long_text_content = 1;
}

// ------------------------------------
// AI 摘要响应 (用于 MSG_AI_SUMMARY_RESPONSE)
// ------------------------------------
message AiSummaryResponse {
  string original_hash = 1; // (原文内容的 hash，用于校验)
  string summary_text = 2;
}
```

### 4.2. 通信流程：AI 协同 (针对聊天摘要)

根据您的决策（推迟实现，优先使用高性能节点），AI 协同将是实现 **聊天摘要** 这类高消耗功能的最优解。

**节点 A (RK3566):** 用户请求对一段长聊天进行摘要。

**节点 A (逻辑):**

- `CommunicationService` 检查已知的 `PeerNodes` 列表。
    
- 查找 `has_gpu == true` 的高性能节点 (节点 B)。
    

**(情况 1: 找到高性能节点)**

- **节点 A -> 节点 B (Windows GPU):** 发送 `MSG_AI_SUMMARY_REQUEST`，附带聊天文本。
    
- **节点 B (高性能):** 收到请求，调用本地的 `AIEngine` (即 `WindowsGpuEngine`) 执行摘要。
    
- **节点 B -> 节点 A:** 发送 `MSG_AI_SUMMARY_RESPONSE`，附带摘要结果。
    

**(情况 2: 未找到高性能节点)**

- **节点 A (逻辑):** 回退到本地。
    
- **节点 A:** 调用本地的 `AIEngine`，该引擎会加载一个轻量级的摘要模型（如果已提供）在 NPU 或 CPU 上运行。
    
- 向用户显示（可能是效果稍差的）本地摘要结果。
    

# 5. 技术栈选型推荐

|层面|推荐选项 1 (性能优先)|推荐选项 2 (开发效率优先)|
|---|---|---|
|**语言**|**C++ 20**|**C# (.NET 8)**|
|**UI 框架**|**Qt 6**|**.NET MAUI** 或 **Avalonia UI**|
|**通信**|Boost.Asio 或 Qt Network|.NET Sockets (System.Net.Sockets)|
|**AI 推理**|**ONNX Runtime (C++ API)**|**ONNX Runtime (C# NuGet包)**|
|**NPU (RK3566)**|`librknnrt` (C API)|通过 P/Invoke 调用 C API|
|**数据库**|SQLite (原生 C API)|SQLite (通过 `Microsoft.Data.Sqlite`)|
|**数据协议**|Protobuf|Protobuf 或 JSON|

**结论：** 鉴于 RK3566 平台（Embedded Linux）的特性，**C++ + Qt 6** 是最稳健、性能最高、跨平台坑最少的选择。Qt 自身提供了强大的网络、UI 和系统 API 封装。

# 6. 数据库设计 (SQLite)

### `ChatHistory` (聊天记录)

- `id` (INTEGER, PRIMARY KEY AUTOINCREMENT)
    
- `session_id` (TEXT): 对方/群组 ID
    
- `sender_id` (TEXT)
    
- `timestamp` (INTEGER): Unix 时间戳
    
- `content_type` (INTEGER): 0=Text, 1=Image, 2=File, 3=Voice
    
- `content_data` (TEXT): 消息内容或文件路径
    
- **`content_embedding` (BLOB): 用于语义搜索的向量**
    

### `ChatHistory_FTS` (全文检索虚拟表)

- 使用 FTS5 索引 `ChatHistory` 表的 `content_data` 列。
    

### `PeerNodes` (已知节点)

- `user_id` (TEXT, PRIMARY KEY)
    
- `user_name` (TEXT)
    
- `group_name` (TEXT): **：用于支持分组功能 (需求 2, 3)**
    
- `last_seen_ip` (TEXT)
    
- `last_seen_time` (INTEGER)
    
- `has_gpu` (INTEGER, 0/1)
    
- `has_npu` (INTEGER, 0/1)

# 7. 详细的文件结构 (C++ & Qt 推荐)

一个清晰的目录结构是项目成功的关键。这里是一个推荐的、基于模块化的 C++ (Qt) 项目结构：

```
ai-feiqiu/
├── CMakeLists.txt           # 顶层 CMake 配置文件
├── README.md
├── doc/                     # 文档 (架构图、rknn 模型转换说明等)
├── 3rdparty/                # 第三方库 (如 ONNX Runtime, rknn_api, protobuf)
│   ├── onnxruntime/
│   ├── rknn_api/
│   └── protobuf/
├── src/                     # 源码
│   ├── CMakeLists.txt
│   │
│   ├── core/                # 核心非 UI 逻辑 (100% 跨平台)
│   │   ├── CMakeLists.txt
│   │   ├── global/            # 全局定义 (枚举, 常量, 日志)
│   │   │   ├── app_config.h
│   │   │   └── logging.h
│   │   ├── models/            # 数据模型 (P2P 节点, 消息结构)
│   │   │   ├── peer_node.h
│   │   │   └── message.h
│   │   ├── network/           # 网络通信
│   │   │   ├── communication_service.h
│   │   │   ├── peer_discovery.h      # (UDP 广播)
│   │   │   ├── peer_session.h        # (TCP 会话)
│   │   │   └── file_transfer.h
│   │   ├── database/          # 数据库服务
│   │   │   ├── database_service.h
│   │   │   └── i_repository.h        # (仓储接口)
│   │   ├── ai/                # AI 引擎核心
│   │   │   ├── ai_engine.h           # (AI 工厂)
│   │   │   └── i_accelerator.h       # (HAL 抽象接口)
│   │   └── protobuf/          # Protobuf 生成的 .h 和 .cpp
│   │       ├── message.pb.h
│   │       └── message.pb.c
│   │
│   ├── platform/            # 平台相关的实现 (AI 加速器)
│   │   ├── CMakeLists.txt
│   │   ├── windows/           # Windows 平台
│   │   │   ├── gpu_engine_directml.h
│   │   │   └── gpu_engine_directml.cpp
│   │   ├── rk3566/            # RK3566 平台
│   │   │   ├── npu_engine_rknn.h
│   │   │   └── npu_engine_rknn.cpp
│   │   └── common/            # 通用 CPU 回退
│   │       ├── cpu_fallback_engine.h
│   │       └── cpu_fallback_engine.cpp
│   │
│   ├── ui/                    # UI 层 (视图 和 视图模型)
│   │   ├── CMakeLists.txt
│   │   ├── main.cpp           # 程序入口
│   │   ├── main_window.h      # 主窗口 (View)
│   │   ├── main_window.ui     # (Qt Designer 文件)
│   │   │
│   │   ├── viewmodels/        # 视图模型 (ViewModels)
│   │   │   ├── main_viewmodel.h
│   │   │   ├── chat_viewmodel.h
│   │   │   └── settings_viewmodel.h
│   │   │
│   │   └── widgets/           # 自定义 UI 控件 (Views)
│   │       ├── peer_list_widget.h
│   │       └── chat_bubble.h
│   │
│   └── app/                   # 应用层 (连接 Core 和 UI)
│       ├── CMakeLists.txt
│       ├── app_service_bus.h  # 服务总线 (解耦)
│       └── main_application.h   # (继承 QCoreApplication)
│
└── tests/                   # 单元测试
    ├── CMakeLists.txt
    ├── core/
    │   └── test_network.cpp
    └── platform/
        └── test_ai_engine.cpp

```

# 8. 核心对象与类设计 (C++ & Qt)

基于 MVVM 架构和上述文件结构，这是关键类的职责设计：

### 1. 应用与服务总线

- **`MainApplication` (继承 `QApplication`)**
    
    - **职责:** 程序的入口和所有权。负责创建和持有所有单例服务（如 `CommunicationService`, `AIEngine`）。
        
    - **关联:** 持有 `AppServiceBus`。
        
- **`AppServiceBus` (单例)**
    
    - **职责:** 作为一个全局的服务定位器 (Service Locator) 或依赖注入 (DI) 容器。它允许 `ViewModel` 和其他服务以解耦的方式获取对 `DatabaseService` 或 `AIEngine` 的引用。
        
    - **方法:**（示例）
        
        - `CommunicationService* GetCommService()`
            
        - `AIEngine* GetAIEngine()`
            
    - **方法:** `CommunicationService* GetCommService()`, `AIEngine* GetAIEngine()`
        

### 2. Model: 通信模块 (src/core/network/)

- **`CommunicationService` (单例, 继承 `QObject`)**
    
    - **职责:** 统管所有网络活动。初始化、启动和停止 `PeerDiscovery` 和 TCP 服务.
        
    - **信号 (Signals):** `peerOnline(PeerNode node)`, `peerOffline(QString userId)`, `newMessageReceived(Message msg)`, `imageReceived(QByteArray data, bool isNsfw)`
        
    - **逻辑 (新增 - 接收端 NSFW):** 当 `PeerSession` 接收文件（图片）完成后，`CommunicationService` 必须在将数据交给 UI 之前，调用 `AIEngine::CheckNsfw()`。然后发出 `imageReceived` 信号，并附带 `isNsfw` 标志。
        
    - **关联:** 持有 `PeerDiscovery` 和一个 `PeerSession` 列表。
        
- **`PeerDiscovery` (继承 `QObject`)**
    
    - **职责:** 负责 UDP 广播和监听。使用 `QUdpSocket`。
        
    - **信号:** `discoveryBroadcast()`, `peerFound(UserInfo userInfo, QHostAddress ip)`
        
    - **逻辑:** 定时（如 `QTimer`）发送 `MSG_ONLINE` 广播。
        
- **`PeerSession` (继承 `QObject`)**
    
    - **职责:** 管理与**单个**对等点建立的 TCP 长连接 (`QTcpSocket`)。负责该连接上的消息收发、心跳 (Ping/Pong) 和协议解析 (Protobuf)。
        
    - **信号:** `disconnected()`, `messageReady(Message msg)`, `fileRequestReceived(...)`
        

### Model: AI 引擎 (src/core/ai/ & src/platform/)

- **`AIEngine` (单例)**
    
    - **职责:** AI 工厂类。在程序启动时，它根据当前平台实例化正确的 `I_Accelerator` 实现。
        
    - **关联:** 持有一个 `std::unique_ptr<I_Accelerator>`。
        
    - **(重要 - 针对 NPU 资源管理):** 在 RK3566 平台上，`AIEngine` 还必须充当 **NPU 资源管理器**。由于 NPU (0.8 TOPS) 内存极小，无法同时加载多个模型。
        
    - **管理逻辑 (针对 RK3566):**
        
        - `AIEngine` 内部维护一个 `std::mutex` (NPU 锁) 和一个 `currentModel` (当前加载的模型类型, e.g. `AiTask::NsfwDetection`)。
            
        - 当 `CheckNsfw()` 被调用时:
            
            1. 获取 NPU 锁。
                
            2. 检查 `currentModel` 是否为 `NsfwDetection`。
                
                - **否:** 调用 `rknn_release()` 卸载旧模型，调用 `rknn_init()` 加载 NSFW 模型。更新 `currentModel`。
                    
                - **是:** (缓存命中) 直接使用。
                    
            3. 调用 `rknn_run()` 执行推理。
                
            4. 释放 NPU 锁。
                
        - `GetEmbedding()` (语义搜索) 等其他 AI 功能调用同理。
            
    - **方法:**（示例）
        
        - `bool CheckNsfw(const QByteArray& imageData)`
            
        - `std::string Translate(const std::string& text, const std::string& lang)`
            
        - `std::string Summarize(const std::string& chatHistory)`
            
        - `std::vector<float> GetEmbedding(const std::string& text)`
            
- **`I_Accelerator` (接口)**
    
    - **职责:** 定义硬件加速的统一接口，如 `ai_accelerator.h` 中所示。
        
- **`Rk3566NpuEngine` (继承 `I_Accelerator`)**
    
    - **职责:** RK3566 平台的具体实现。
        
    - **`Initialize()`:** 调用 `rknn_init()`，加载 `.rknn` 模型到 NPU。
        
    - **`RunNsfwCheck()`:** 准备输入数据 (`rknn_inputs_set()`)，调用 `rknn_run()`，处理输出。
        
- **`WindowsGpuEngine` (继承 `I_Accelerator`)**
    
    - **职责:** Windows 平台的具体实现。
        
    - **`Initialize()`:** 创建 ONNX Runtime `Session`，并指定 `DirectML` 或 `CUDA` Provider。
        
    - **`RunNsfwCheck()`:** <em>…… [等] ……</em>

### 4. Model: 数据存储 (src/core/database/)

- **`DatabaseService` (单例, 继承 `QObject`)**
    
    - **职责:** 管理 SQLite 数据库连接 (`QSqlDatabase`)。提供一个线程安全的队列来执行异步的数据库读写，避免阻塞主线程。
        
    - **方法:** `void InitDatabase()`, `void AsyncWriteHistory(const Message& msg)`
        
    - **信号:** `historyWritten()`
        

### 5. ViewModel (src/ui/viewmodels/)

- **`MainViewModel` (继承 `QObject`)**
    
    - **职责:** 主窗口的视图模型。通过 `AppServiceBus` 获取服务实例。
        
    - **关联:** 持有 `PeerListViewModel` 和 `ChatViewModel`。
        
    - **逻辑:** 连接 `CommunicationService` 的 `peerOnline` 信号，并更新 `PeerListViewModel`。
        
- **`ChatViewModel` (继承 `QObject`)**
    
    - **职责:** 聊天界面的状态机。
        
    - **属性 (Properties):** `Q_PROPERTY(QString currentPeerName ...)` (用于 UI 绑定), `Q_PROPERTY(QQmlListProperty<ChatMessage> messages ...)`
        
    - **槽 (Slots):** `void OnSendTextClicked()`, `void OnSendImageClicked(const QByteArray& imageData)`, `void OnImageReceived(const QByteArray& imageData, bool isNsfw)`
        
    - **逻辑 (NSFW 双端检测):**
        
        1. **(发送端) `OnSendImageClicked`:**
            
            - 异步调用 `AIEngine::CheckNsfw()`。
                
            - 如果检测结果为 `true` (不安全)，则**阻止发送**并向用户显示提示。
                
            - 如果为 `false` (安全)，则通过文件传输服务发送图片。
                
        2. **(接收端) `OnImageReceived`:**
            
            - (连接到 `CommunicationService` 的 `imageReceived` 信号)
                
            - 如果 `isNsfw` 为 `true`，则在聊天窗口中显示一个模糊的占位符或警告，而不是原始图片。
                
            - 如果 `isNsfw` 为 `false`，则正常显示图片。