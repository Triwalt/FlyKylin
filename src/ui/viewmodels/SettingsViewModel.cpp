/**
 * @file SettingsViewModel.cpp
 * @brief Implementation of SettingsViewModel for QML settings page
 */

#include "SettingsViewModel.h"

#include "core/config/UserProfile.h"

// Version info (generated by CMake)
#if __has_include("Version.h")
#include "Version.h"
#endif

#include <QSettings>
#include <QFileDialog>
#include <QStandardPaths>
#include <QDir>
#include <QDebug>

namespace flykylin {
namespace ui {

SettingsViewModel::SettingsViewModel(QObject* parent)
    : QObject(parent)
{
    load();
}

void SettingsViewModel::load()
{
    // Load from UserProfile
    flykylin::core::UserProfile& profile = flykylin::core::UserProfile::instance();
    m_userName = profile.userName();
    m_avatarId = profile.avatarPath();
    m_localUserId = profile.userId();

    // Load from QSettings
    QSettings settings("FlyKylin", "FlyKylin");
    m_downloadDirectory = settings.value("paths/downloadDirectory").toString();
    m_chatHistoryDirectory = settings.value("paths/chatHistoryDirectory").toString();
    m_semanticSearchEnabled = settings.value("search/semanticSearchEnabled", false).toBool();
    m_nsfwBlockOutgoing = settings.value("nsfw/blockOutgoing", false).toBool();
    m_nsfwBlockIncoming = settings.value("nsfw/blockIncoming", false).toBool();
    m_nsfwThreshold = settings.value("nsfw/threshold", 0.8).toDouble();
    if (m_nsfwThreshold < 0.0) {
        m_nsfwThreshold = 0.0;
    } else if (m_nsfwThreshold > 1.0) {
        m_nsfwThreshold = 1.0;
    }
}

void SettingsViewModel::setUserName(const QString& userName)
{
    if (m_userName == userName) {
        return;
    }

    m_userName = userName;
    flykylin::core::UserProfile::instance().setUserName(userName);
    emit userNameChanged();
}

void SettingsViewModel::setAvatarId(const QString& avatarId)
{
    if (m_avatarId == avatarId) {
        return;
    }

    m_avatarId = avatarId;
    flykylin::core::UserProfile::instance().setAvatarPath(avatarId);
    emit avatarIdChanged();
}

void SettingsViewModel::setDownloadDirectory(const QString& dir)
{
    if (m_downloadDirectory == dir) {
        return;
    }

    m_downloadDirectory = dir;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("paths/downloadDirectory", m_downloadDirectory);
    settings.sync();

    emit downloadDirectoryChanged();
}

void SettingsViewModel::setChatHistoryDirectory(const QString& dir)
{
    if (m_chatHistoryDirectory == dir) {
        return;
    }

    m_chatHistoryDirectory = dir;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("paths/chatHistoryDirectory", m_chatHistoryDirectory);
    settings.sync();

    emit chatHistoryDirectoryChanged();
}

void SettingsViewModel::setSemanticSearchEnabled(bool enabled)
{
    if (m_semanticSearchEnabled == enabled) {
        return;
    }

    m_semanticSearchEnabled = enabled;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("search/semanticSearchEnabled", m_semanticSearchEnabled);
    settings.sync();

    emit semanticSearchEnabledChanged();
}

void SettingsViewModel::setNsfwBlockOutgoing(bool enabled)
{
    if (m_nsfwBlockOutgoing == enabled) {
        return;
    }

    m_nsfwBlockOutgoing = enabled;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("nsfw/blockOutgoing", m_nsfwBlockOutgoing);
    settings.sync();

    emit nsfwBlockOutgoingChanged();
}

void SettingsViewModel::setNsfwBlockIncoming(bool enabled)
{
    if (m_nsfwBlockIncoming == enabled) {
        return;
    }

    m_nsfwBlockIncoming = enabled;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("nsfw/blockIncoming", m_nsfwBlockIncoming);
    settings.sync();

    emit nsfwBlockIncomingChanged();
}

void SettingsViewModel::setNsfwThreshold(double threshold)
{
    double clamped = threshold;
    if (clamped < 0.0) {
        clamped = 0.0;
    } else if (clamped > 1.0) {
        clamped = 1.0;
    }

    if (m_nsfwThreshold == clamped) {
        return;
    }

    m_nsfwThreshold = clamped;

    QSettings settings("FlyKylin", "FlyKylin");
    settings.setValue("nsfw/threshold", m_nsfwThreshold);
    settings.sync();

    emit nsfwThresholdChanged();
}

void SettingsViewModel::chooseDownloadDirectory()
{
    QString currentDir = m_downloadDirectory;

    if (currentDir.isEmpty()) {
        QString baseDir = QStandardPaths::writableLocation(QStandardPaths::DownloadLocation);
        if (baseDir.isEmpty()) {
            baseDir = QDir::homePath();
        }
        currentDir = baseDir;
    }

    QString selectedDir = QFileDialog::getExistingDirectory(nullptr,
                                                            QObject::tr("选择下载目录"),
                                                            currentDir);
    if (selectedDir.isEmpty()) {
        return;
    }

    setDownloadDirectory(selectedDir);
    qInfo() << "[SettingsViewModel] Download directory set to" << selectedDir;
}

QString SettingsViewModel::appVersion() const
{
#ifdef FLYKYLIN_VERSION_STRING
    return FLYKYLIN_VERSION_STRING;
#else
    return "1.0.0";
#endif
}

QString SettingsViewModel::buildDate() const
{
#ifdef FLYKYLIN_BUILD_DATE
    return FLYKYLIN_BUILD_DATE;
#else
    return __DATE__;
#endif
}

QString SettingsViewModel::qtVersion() const
{
    return QString(qVersion());
}

QString SettingsViewModel::platform() const
{
#ifdef RK3566_PLATFORM
    return "RK3566 (ARM64)";
#elif defined(Q_OS_WIN)
    return "Windows";
#elif defined(Q_OS_LINUX)
    return "Linux";
#else
    return "Unknown";
#endif
}

QStringList SettingsViewModel::features() const
{
    QStringList list;
    
    // Core features
    list << QObject::tr("P2P通讯");
    list << QObject::tr("文件传输");
    list << QObject::tr("群组聊天");
    
    // AI features
#if defined(ONNXRUNTIME_FOUND) && ONNXRUNTIME_FOUND
    list << QObject::tr("语义搜索");
    list << QObject::tr("NSFW检测");
#endif

#if defined(RKNPU_FOUND) && RKNPU_FOUND
    list << QObject::tr("NPU加速");
#endif

    return list;
}

} // namespace ui
} // namespace flykylin
